#!/usr/bin/env bash
LC_ALL=C

# Display help usage
function usage () {
  echo
  echo "Usage"
  echo "  $0"
  echo
}

function sync_from() {
    if [ -z "${1}" ] || [ -z "${2}" ]; then
        echo "ERROR! Source stages to sync were not passed."
        exit 1
    fi

    local B_SOURCE="${1}"
    local R_SOURCE="${2}"

    if [ -d "${B}" ] && [ -d "${R}" ]; then
        echo "Syncing from ${B_SOURCE}..."
        rsync -aHAXx --delete "${B_SOURCE}/" "${B}/"
        echo "Syncing from ${R_SOURCE}..."
        rsync -aHAXx --delete "${R_SOURCE}/" "${R}/"
    else
        echo "ERROR! Either ${B} or ${R} do not exist!"
        exit 1
    fi
}

function nspawn() {
    # Create basic resolv.conf for bind mounting inside the container
    echo "nameserver 1.1.1.1" > "${R_STAGE_0}/resolv.conf"

    if pidof apt-cacher-ng && [ -d "${R}/etc/apt/apt.conf.d" ]; then
        echo "Acquire::http { Proxy \"http://${APT_CACHE_IP}:3142\"; }" > "${R}/etc/apt/apt.conf.d/90cache"
    fi

    # Make sure the container has a machine-id
    systemd-machine-id-setup --root "${R}" --print

    echo "RUNNING: ${@}"
    # Bind mount resolv.conf and the firmware, set the hostname and spawn
    systemd-nspawn \
      --resolv-conf=off \
      --bind-ro="${R_STAGE_0}/resolv.conf":/etc/resolv.conf \
      --bind="${B}":/boot/firmware \
      --machine="${FLAVOUR}" \
      --directory "${R}" "${@}"

    if [ -e "${R}/etc/apt/apt.conf.d/90cache" ]; then
        rm -f "${R}/etc/apt/apt.conf.d/90cache"
    fi
}

function stage_01_bootstrap() {
    local REPO=""
    export B="${B_STAGE_1}"
    export R="${R_STAGE_1}"

    rm -rf "${B_STAGE_1}"/*
    rm -rf "${R_STAGE_1}"/*

    # Required tools on the host
    apt-get -y install binfmt-support debootstrap git qemu-user-static rsync \
    systemd-container ubuntu-keyring whois xz-utils

    # Bootstrap a minimal Ubuntu
    #   Include cloud-guest-utils; prevents cloud-image-utils, and therefore qemu-system-x86, being installed later

    if pidof apt-cacher-ng; then
        REPO="http://localhost:3142/ports.ubuntu.com/"
    else
        REPO="http://ports.ubuntu.com/"
    fi

    debootstrap \
        --arch="${IMG_ARCH}" \
        --cache-dir="${R_STAGE_0}" \
        --components=main,restricted,universe,multiverse \
        --foreign \
        --include=cloud-guest-utils \
        "${IMG_RELEASE}" "${R}" "${REPO}"
    nspawn /debootstrap/debootstrap \
        --second-stage

    cat <<EOM >"${R}/etc/apt/sources.list"
deb http://ports.ubuntu.com/ ${IMG_RELEASE} main restricted universe multiverse
deb-src http://ports.ubuntu.com/ ${IMG_RELEASE} main restricted universe multiverse

deb http://ports.ubuntu.com/ ${IMG_RELEASE}-updates main restricted universe multiverse
deb-src http://ports.ubuntu.com/ ${IMG_RELEASE}-updates main restricted universe multiverse

deb http://ports.ubuntu.com/ ${IMG_RELEASE}-security main restricted universe multiverse
deb-src http://ports.ubuntu.com/ ${IMG_RELEASE}-security main restricted universe multiverse

deb http://ports.ubuntu.com/ ${IMG_RELEASE}-backports main restricted universe multiverse
deb-src http://ports.ubuntu.com/ ${IMG_RELEASE}-backports main restricted universe multiverse
EOM

    nspawn hostnamectl --static set-hostname "${FLAVOUR}"
    echo "${FLAVOUR}" > "${R}/etc/hostname"
    sed -i "1s|.*|127.0.0.1\tlocalhost ${FLAVOUR}|" "${R}/etc/hosts"

    if [ "${IMG_VER}" == "20.04" ]; then
        nspawn apt-add-repository --yes ppa:ubuntu-pi-flavour-makers/ppa
    fi

    nspawn apt-get -y update
    nspawn apt-get -y upgrade
    nspawn apt-get -y dist-upgrade

    # Install first boot filesystem expansion
    nspawn apt-get -y install cloud-initramfs-growroot

    # Add standard Ubuntu userspace
    nspawn apt-get -y install standard^

    nspawn apt-get -y autoclean
    nspawn apt-get -y clean
}

function stage_02_desktop() {
    export B="${B_STAGE_2}"
    export R="${R_STAGE_2}"
    sync_from "${B_STAGE_1}" "${R_STAGE_1}"

    nspawn apt-get -y update
    nspawn apt-get -y install ubuntu-mate-core^
    nspawn apt-get -y install ubuntu-mate-desktop^
}

function stage_03_snap() {
    export B="${B_STAGE_3}"
    export R="${R_STAGE_3}"
    sync_from "${B_STAGE_2}" "${R_STAGE_2}"

    local SEED_CHANNEL="stable/ubuntu-${IMG_VER}"

    mkdir -p ${R}/var/lib/snapd/seed/{assertions,snaps}
    snap known --remote model series=16 model=generic-classic brand-id=generic > "${R}/var/lib/snapd/seed/assertions/model"
    local ACCOUNT_KEY=$(grep "^sign-key-sha3-384" "${R}/var/lib/snapd/seed/assertions/model" | cut -d':' -f2 | sed 's/ //g')
    snap known --remote account account-id=generic > "${R}/var/lib/snapd/seed/assertions/account"
    snap known --remote account-key public-key-sha3-384="${ACCOUNT_KEY}" > "${R}/var/lib/snapd/seed/assertions/account-key"

    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps core18
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps core20
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps snapd
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps --channel="${SEED_CHANNEL}" ubuntu-mate-welcome
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps software-boutique
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps ubuntu-mate-pi
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps --channel="${SEED_CHANNEL}" gtk-theme-yaru-mate
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps --channel="${SEED_CHANNEL}" icon-theme-yaru-mate

    nspawn snap prepare-image \
        --arch="${IMG_ARCH}" \
        --classic \
        --snap=core18 \
        --snap=core20 \
        --snap=snapd \
        --snap=gtk-theme-yaru-mate="${SEED_CHANNEL}" \
        --snap=icon-theme-yaru-mate="${SEED_CHANNEL}" \
        --snap=ubuntu-mate-welcome="${SEED_CHANNEL}" \
        --snap=software-boutique \
        --snap=ubuntu-mate-pi \
        /var/lib/snapd/seed/assertions/model /

    mv "${R}"/var/lib/snapd/seed/snaps/*.assert "${R}/var/lib/snapd/seed/assertions/"
    rm -f "${R}"/var/lib/snapd/seed/assertions/*.account
    rm -f "${R}"/var/lib/snapd/seed/assertions/*.account-key
    rm -f "${R}"/var/lib/snapd/seed/assertions/*.snap-declaration
    rm -f "${R}"/var/lib/snapd/seed/assertions/*.snap-revision
}

function stage_04_kernel() {
    export B="${B_STAGE_4}"
    export R="${R_STAGE_4}"
    sync_from "${B_STAGE_3}" "${R_STAGE_3}"

    if [ "${IMG_VER}"  == "20.04" ]; then
        cat <<EOM > "${B}/README"
An overview of the files on the /boot/firmware partition (the 1st partition
on the SD card) used by the Ubuntu boot process (roughly in order) is as
follows:

* bootcode.bin   - this is the second stage bootloader loaded by all pis with
                   the exception of the pi4 (where this is replaced by flash
                   memory)
* config.txt     - the first configuration file read by the boot process
* syscfg.txt     - the file in which system modified configuration will be
                   placed, included by config.txt
* usercfg.txt    - the file in which user modified configuration should be
                   placed, included by config.txt
* start*.elf     - the third stage bootloader, which handles device-tree
                   modification and which loads...
* uboot*.bin     - various u-boot binaries for different pi platforms; these
                   are launched as the "kernel" by config.txt
* boot.scr       - the boot script executed by uboot*.bin which in turn
                   loads...
* vmlinuz        - the Linux kernel, executed by boot.scr
* initrd.img     - the initramfs, executed by boot.scr
EOM

        cat <<EOM >> "${B}/config.txt"

# Enable the FKMS ("Fake" KMS) graphics overlay, enable the camera firmware
# and allocate 128Mb to the GPU memory
dtoverlay=vc4-fkms-v3d
gpu_mem=128
start_x=1

# Comment out the following line if the edges of the desktop appear outside
# the edges of your display
disable_overscan=1

# If you have issues with audio, you may try uncommenting the following line
# which forces the HDMI output into HDMI mode instead of DVI (which doesn't
# support audio output)
#hdmi_drive=2

# If you have a CM4, uncomment the following line to enable the USB2 outputs
# on the IO board (assuming your CM4 is plugged into such a board)
#dtoverlay=dwc2,dr_mode=host
EOM
        sed -i 's/enable_uart=1/enable_uart=0/' "${B}/config.txt"
        sed -i 's/enable_uart=1/enable_uart=0/' "${B}/syscfg.txt"
    else
        cat <<'EOM' > "${B}/README"
An overview of the files on the /boot/firmware partition (the 1st partition
on the SD card) used by the Ubuntu boot process (roughly in order) is as
follows:

* bootcode.bin   - this is the second stage bootloader loaded by all pis with
                   the exception of the pi4 (where this is replaced by flash
                   memory)
* config.txt     - the configuration file read by the boot process
* start*.elf     - the third stage bootloader, which handles device-tree
                   modification and which loads...
* vmlinuz        - the Linux kernel
* cmdline.txt    - the Linux kernel command line
* initrd.img     - the initramfs
EOM

        # No uboot since 20.10
        if [ "${IMG_ARCH}"  == "arm64" ]; then
            ARM64="arm_64bit=1"
        else
            ARM64=""
        fi

        cat <<EOM > "${B}/config.txt"
[pi4]
max_framebuffers=2

[all]
${ARM64}
kernel=vmlinuz
cmdline=cmdline.txt
initramfs initrd.img followkernel

# Enable the audio output, I2C and SPI interfaces on the GPIO header
dtparam=audio=on
dtparam=i2c_arm=on
dtparam=spi=on

# Enable the full KMS graphics overlay, as recommended by Ludo
dtoverlay=vc4-fkms-v3d
gpu_mem=128
start_x=1

# Comment out the following line if the edges of the desktop appear outside
# the edges of your display
disable_overscan=1

# If you have issues with audio, you may try uncommenting the following line
# which forces the HDMI output into HDMI mode instead of DVI (which doesn't
# support audio output)
hdmi_drive=2

# If you have a CM4, uncomment the following line to enable the USB2 outputs
# on the IO board (assuming your CM4 is plugged into such a board)
#dtoverlay=dwc2,dr_mode=host
EOM
    fi

    echo "net.ifnames=0 dwc_otg.lpm_enable=0 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline rootwait fixrtc consoleblank=0 vt.global_cursor_default=0 quiet splash" > "${B}/cmdline.txt"

    cat <<'EOM' > "${R}/etc/fstab"
LABEL=writable      /               ext4    defaults,noatime,x-systemd.growfs   0   0
LABEL=system-boot   /boot/firmware  vfat    defaults                            0   1
EOM

    nspawn apt-get -y install libraspberrypi0 libraspberrypi-bin \
    linux-firmware-raspi2 linux-headers-raspi linux-image-raspi \
    linux-modules-extra-raspi pi-bluetooth raspi-config rpi-eeprom

    local NEW_KERNEL=$(ls -1 "${R}"/boot/vmlinuz-* | tail -n1 | awk -F/ '{print $NF}' | cut -d'-' -f2-4)
    if [ -z "${NEW_KERNEL}" ]; then
        echo "ERROR! Could not detect the new kernel version"
        exit 1
    fi
    echo "Kernel: ${NEW_KERNEL}"

    # Copy firmware, devicetree, overlays and kernel to the boot file system
    cp -v "${R}/lib/linux-firmware-raspi2/"* "${B}/"
    cp -av "${R}/lib/firmware/${NEW_KERNEL}/device-tree/"* "${B}/"

    # Move the arm64 device-tree
    if [ -d "${B}/broadcom" ]; then
        mv -v "${B}/broadcom/"*.dtb "${B}"/
        rm -rf "${B}/broadcom"
    fi

    cp -av "${R}/boot/vmlinuz-${NEW_KERNEL}" "${B}/vmlinuz"
    cp -av "${R}/boot/initrd.img-${NEW_KERNEL}" "${B}/initrd.img"
}

function stage_05_config() {
    export B="${B_STAGE_5}"
    export R="${R_STAGE_5}"
    sync_from "${B_STAGE_4}" "${R_STAGE_4}"

# Instruct netplan to hand all network management to NetworkManager
    cat <<EOM > "${R}/etc/netplan/01-network-manager-all.yaml"
# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager
EOM

    # Disable Wifi power saving to improve WiFi performance on the Pi
    cat <<EOM > "${R}/etc/NetworkManager/conf.d/ZZraspi-wifi-powersave-off.conf"
[connection]
wifi.powersave = 2
EOM

    local DATE=""
    DATE=$(date +%m%H%M%S)
    local PASSWD=""
    PASSWD=$(mkpasswd -m sha-512 oem "${DATE}")
    nspawn addgroup --gid 29999 oem

    nspawn adduser --gecos "OEM Configuration (temporary user)" --add_extra_groups --disabled-password --gid 29999 --uid 29999 oem
    nspawn usermod -a -G adm,sudo -p "${PASSWD}" oem

    nspawn apt-get -y install --no-install-recommends oem-config-gtk ubiquity-frontend-gtk ubiquity-ubuntu-artwork oem-config-slideshow-ubuntu-mate
    # Force the slideshow to use Ubuntu MATE artwork.
    sed -i 's/oem-config-slideshow-ubuntu/oem-config-slideshow-ubuntu-mate/' "${R}/usr/lib/ubiquity/plugins/ubi-usersetup.py"
    sed -i 's/oem-config-slideshow-ubuntu/oem-config-slideshow-ubuntu-mate/' "${R}/usr/sbin/oem-config-remove-gtk"
    sed -i 's/ubiquity-slideshow-ubuntu/ubiquity-slideshow-ubuntu-mate/' "${R}/usr/sbin/oem-config-remove-gtk"

    # Create files/dirs Ubiquity requires
    mkdir -p "${R}/var/log/installer"
    touch "${R}/var/lib/oem-config/run"
    touch "${R}/var/log/installer/debug"
    touch "${R}/var/log/syslog"
    nspawn chown syslog:adm /var/log/syslog
    nspawn /usr/sbin/oem-config-prepare --quiet

    # Install seeded snaps during oem-setup
    nspawn ln -s /lib/systemd/system/snapd.seeded.service /etc/systemd/system/oem-config.target.wants/snapd.seeded.service

    cat <<EOM > "${R}/usr/share/glib-2.0/schemas/50_ubuntu-mate-raspi-tweaks.gschema.override"
[org.mate.interface]
enable-animations=false

[org.mate.Marco.general]
compositing-manager=false

[org.mate.session.required-components]
windowmanager='marco-no-composite'
EOM

    nspawn glib-compile-schemas /usr/share/glib-2.0/schemas/

    # Create Raspberry Pi specific groups.
    nspawn groupadd -f --system gpio
    nspawn groupadd -f --system i2c
    nspawn groupadd -f --system input
    nspawn groupadd -f --system spi

    cat <<'EOM' > "${R}/usr/local/sbin/adduser.local"
#!/bin/sh
# This script is executed as the final step when calling `adduser`
# USAGE:
#   adduser.local USER UID GID HOME

# Add user to the Raspberry Pi specific groups
usermod -a -G adm,gpio,i2c,input,spi,video $1
EOM
    chmod 755 "${R}/usr/local/sbin/adduser.local"
}

function stage_06_clean() {
    export B="${B_STAGE_6}"
    export R="${R_STAGE_6}"
    sync_from "${B_STAGE_5}" "${R_STAGE_5}"

    nspawn apt-get -y autoremove
    nspawn apt-get -y autoclean
    nspawn apt-get -y clean

    rm -f "${B}"/{*.bak,*.old}
    rm -f "${R}"/boot/{*.bak,*.old}
    rm -f "${R}"/etc/ssh/ssh_host_*_key*
    rm -f "${R}"/etc/apt/*.save
    rm -f "${R}"/etc/apt/apt.conf.d/90cache
    rm -f "${R}"/etc/apt/sources.list.d/*.save
    rm -f "${R}"/var/log/apt/*
    rm -f "${R}"/var/log/alternatives.log
    rm -f "${R}"/var/log/dpkg.log
    rm -f "${R}"/var/log/fontconfig.log
    rm -rf "${R}"/tmp/*
    rm -f "${R}"/var/crash/*
    rm -f "${R}"/var/cache/apt/*
    rm -rf "${R}"/var/cache/apt/archives/*
    rm -f "${R}"/var/cache/debconf/*-old
    rm -rf "${R}"/var/lib/apt/lists/*
    rm -f "${R}"/var/lib/dpkg/*-old
    [ -L "${R}"/var/lib/dbus/machine-id ] || rm -f "${R}"/var/lib/dbus/machine-id
    echo '' > "${R}"/etc/machine-id
}

function stage_07_image() {
    export B="${B_STAGE_6}"
    export R="${R_STAGE_6}"

    # Build the image file
    local SIZE_IMG=""
    SIZE_IMG=$(du -csh "${R}" | tail -n1 | cut -d'.' -f1)
    ((SIZE_IMG+=2))
    local SIZE_BOOT="256MiB"

    # Remove old images.
    rm -fv "${TMP_DIR}/${IMG_OUT}"

    # Create an empty file file.
    dd if=/dev/zero of="${TMP_DIR}/${IMG_OUT}" bs=1MB count=1
    dd if=/dev/zero of="${TMP_DIR}/${IMG_OUT}" bs=1MB count=0 seek=$(( SIZE_IMG * 1000 ))

    # Initialising: msdos
    parted -s "${TMP_DIR}/${IMG_OUT}" mktable msdos
    echo "Creating /boot/firmware partition"
    parted -a optimal -s "${TMP_DIR}/${IMG_OUT}" mkpart primary fat32 1 "${SIZE_BOOT}"
    echo "Creating / partition"
    parted -a optimal -s "${TMP_DIR}/${IMG_OUT}" mkpart primary ext4 "${SIZE_BOOT}" 100%
    echo "Making partition 1 bootable"
    parted -s "${TMP_DIR}/${IMG_OUT}" set 1 boot on

    PARTED_OUT=$(parted -s "${TMP_DIR}/${IMG_OUT}" unit b print)
    BOOT_OFFSET=$(echo "${PARTED_OUT}" | grep -e '^ 1'| xargs echo -n \
    | cut -d" " -f 2 | tr -d B)
    BOOT_LENGTH=$(echo "${PARTED_OUT}" | grep -e '^ 1'| xargs echo -n \
    | cut -d" " -f 4 | tr -d B)

    ROOT_OFFSET=$(echo "${PARTED_OUT}" | grep -e '^ 2'| xargs echo -n \
    | cut -d" " -f 2 | tr -d B)
    ROOT_LENGTH=$(echo "${PARTED_OUT}" | grep -e '^ 2'| xargs echo -n \
    | cut -d" " -f 4 | tr -d B)

    BOOT_LOOP=$(losetup --show -f -o "${BOOT_OFFSET}" --sizelimit "${BOOT_LENGTH}" "${TMP_DIR}/${IMG_OUT}")
    ROOT_LOOP=$(losetup --show -f -o "${ROOT_OFFSET}" --sizelimit "${ROOT_LENGTH}" "${TMP_DIR}/${IMG_OUT}")
    echo "/boot/firmware: offset ${BOOT_OFFSET}, length ${BOOT_LENGTH}"
    echo "/:              offset ${ROOT_OFFSET}, length ${ROOT_LENGTH}"

    mkfs.vfat -n system-boot -S 512 -s 16 -v "${BOOT_LOOP}"
    mkfs.ext4 -L writable -m 0 "${ROOT_LOOP}"

    MOUNTDIR="${TMP_DIR}/image"
    mkdir -p "${MOUNTDIR}"
    mount -v "${ROOT_LOOP}" "${MOUNTDIR}" -t ext4
    mkdir -p "${MOUNTDIR}/boot/firmware"
    mount -v "${BOOT_LOOP}" "${MOUNTDIR}/boot/firmware" -t vfat
    echo "Syncing root..."
    rsync -aHAXx --delete "${R}"/ "${MOUNTDIR}/"
    echo "Syncing boot..."
    rsync -aHAXx --delete "${B}"/ "${MOUNTDIR}/boot/firmware/"
    mkdir -p "${MOUNTDIR}/.disk"
    date +"%Y%m%d" > "${MOUNTDIR}/.disk/info"
    sync
    umount -l "${MOUNTDIR}/boot/firmware"
    umount -l "${MOUNTDIR}"
    losetup -d "${ROOT_LOOP}"
    losetup -d "${BOOT_LOOP}"
    ls -lh "${TMP_DIR}/${IMG_OUT}"
    rm -rf "${MOUNTDIR}"

    # NOTE! Disabled while iterating
    echo "Compressing ${IMG_OUT}.xz"
    rm "${TMP_DIR}/${IMG_OUT}.xz" 2>/dev/null
    xz --keep -T 0 "${TMP_DIR}/${IMG_OUT}"
    ls -lh "${TMP_DIR}/${IMG_OUT}.xz"
}

function stage_08_hash() {
    export B="${B_STAGE_6}"
    export R="${R_STAGE_6}"

    local HASH="sha256"
    local KEY="FFEE1E5C"

    local OUT_HASH="${TMP_DIR}/${IMG_OUT}.xz.${HASH}"
    local OUT_SIGN="${TMP_DIR}/${IMG_OUT}.xz.${HASH}.sign"

    rm -f "${OUT_HASH}"
    rm -f "${OUT_SIGN}"

    if [ -e "${TMP_DIR}/${IMG_OUT}.xz" ]; then
        echo "Hashing ${IMG_OUT}.xz"
        ${HASH}sum "${TMP_DIR}/${IMG_OUT}.xz" > "${OUT_HASH}"
        sed -i -r "s/ .*\/(.+)/  \1/g" "${OUT_HASH}"
        gpg --default-key ${KEY} --armor --output "${OUT_SIGN}" --detach-sig "${OUT_HASH}"
    else
        echo "WARNING! Didn't find ${TMP_DIR}/${IMG_OUT} to hash."
    fi
}

if [ "$(id -u)" -ne 0 ]; then
    echo "ERROR! Root permissions required."
    exit 1
fi

APT_CACHE_IP=$(ip route get 1.1.1.1 | head -n 1 | cut -d' ' -f 7)
FLAVOUR="ubuntu-mate"
IMG_QUALITY=""
IMG_QUALITY="-beta2"
IMG_VER="21.10"
IMG_RELEASE="impish"
IMG_ARCH="arm64"
IMG_OUT="${FLAVOUR}-${IMG_VER}${IMG_QUALITY}-desktop-${IMG_ARCH}+raspi.img"
TMP_DIR="$(pwd)"

# Create caches
for LOOP in 0 1 2 3 4 5 6 7 8 9; do
    case ${LOOP} in
      0)
        export R_STAGE_${LOOP}="${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${IMG_VER}/${LOOP}_cache"
        mkdir -p "${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${IMG_VER}/${LOOP}_cache" 2>/dev/null
        ;;
      *)
        export B_STAGE_${LOOP}="${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${IMG_VER}/${LOOP}_boot"
        export R_STAGE_${LOOP}="${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${IMG_VER}/${LOOP}_root"
        mkdir -p "${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${IMG_VER}/${LOOP}_boot" 2>/dev/null
        mkdir -p "${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${IMG_VER}/${LOOP}_root/boot/firmware" 2>/dev/null
        ;;
    esac
done

stage_01_bootstrap
stage_02_desktop
stage_03_snap
stage_04_kernel
stage_05_config
stage_06_clean
stage_07_image
#stage_08_hash
