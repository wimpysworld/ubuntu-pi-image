#!/usr/bin/env bash
LC_ALL=C

# Display help usage
function usage () {
  echo
  echo "Usage"
  echo "  $0 --img ubuntu-20.04.1-preinstalled-server-arm64+raspi.img"
  echo
}

function sync_from() {
    if [ -z "${1}" ] || [ -z "${2}" ]; then
        echo "ERROR! Source stages to sync were not passed."
        exit 1
    fi

    local B_SOURCE="${1}"
    local R_SOURCE="${2}"

    if [ -d "${B}" ] && [ -d "${R}" ]; then
        echo "Syncing from ${B_SOURCE}..."
        rsync -aHAXx --delete "${B_SOURCE}/" "${B}/"
        echo "Syncing from ${R_SOURCE}..."
        rsync -aHAXx --delete "${R_SOURCE}/" "${R}/"
    else
        echo "ERROR! Either ${B} or ${R} do not exist!"
        exit 1
    fi
}

function nspawn() {
    # Create basic resolv.conf for bind mounting inside the container
    echo "nameserver 1.1.1.1" > "${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${REL_VER}/resolv.conf"

    # Make sure the container has a machine-id
    systemd-machine-id-setup --root "${R}" --print

    # Bind mount resolv.conf and the firmware, set the hostname and spawn
    systemd-nspawn \
      --resolv-conf=off \
      --bind-ro="${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${REL_VER}/resolv.conf":/etc/resolv.conf \
      --bind="${B}":/boot/firmware \
      --hostname="${FLAVOUR}" \
      --machine="${IMG_ARCH}-${FLAVOUR}-${REL_VER}" \
      --directory "${R}" "${@}"
}

function stage_00_tools() {
    # Required tools on the host
    apt-get -y install binfmt-support debootstrap git qemu-user-static rsync \
    systemd-container ubuntu-keyring whois xz-utils
}

function stage_01_unpack() {
    export B="${B_STAGE_1}"
    export R="${R_STAGE_1}"

    # Capture the patition details.
    BOOT_PARTITION=$(fdisk -l "${IMG}" | grep "c W95 FAT32 (LBA)")
    ROOT_PARTITION=$(fdisk -l "${IMG}" | grep "83 Linux")
    echo "${BOOT_PARTITION}"
    echo "${ROOT_PARTITION}"

    # Grab the starting sector of the partitions.
    BOOT_START_SECTOR=$(echo "${BOOT_PARTITION}" | sed -e 's/\*//g' | awk '{print $2}')
    ROOT_START_SECTOR=$(echo "${ROOT_PARTITION}" | sed -e 's/\*//g' | awk '{print $2}')
    #echo "${BOOT_START_SECTOR}"
    #echo "${ROOT_START_SECTOR}"

    # Calculate the start byte of the partitions.
    ((BOOT_START_BYTE=${BOOT_START_SECTOR} * 512))
    ((ROOT_START_BYTE=${ROOT_START_SECTOR} * 512))
    #echo "${BOOT_START_BYTE}"
    #echo "${ROOT_START_BYTE}"

    BOOT_SECTOR_LENGTH=$(echo "${BOOT_PARTITION}" | sed -e 's/\*//g' | awk '{print $4}')
    ROOT_SECTOR_LENGTH=$(echo "${ROOT_PARTITION}" | sed -e 's/\*//g' | awk '{print $4}')

    # Calculate the byte length of the partitions.
    ((BOOT_BYTE_LENGTH=${BOOT_SECTOR_LENGTH} * 512))
    ((ROOT_BYTE_LENGTH=${ROOT_SECTOR_LENGTH} * 512))
    #echo "${BOOT_BYTE_LENGTH}"
    #echo "${ROOT_BYTE_LENGTH}"

    # Mount the partitions to the mount points.
    mount -v -o offset=${BOOT_START_BYTE},sizelimit=${BOOT_BYTE_LENGTH} -t vfat "${IMG}" "${B_STAGE_0}"
    mount -v -o offset=${ROOT_START_BYTE},sizelimit=${ROOT_BYTE_LENGTH} -t ext4 "${IMG}" "${R_STAGE_0}"
    sync_from "${B_STAGE_0}" "${R_STAGE_0}"
    umount -l "${B_STAGE_0}"
    umount -l "${R_STAGE_0}"
    rm -rf "${B_STAGE_0}"
    rm -rf "${R_STAGE_0}"
}

function stage_02_apt() {
    export B="${B_STAGE_2}"
    export R="${R_STAGE_2}"
    sync_from "${B_STAGE_1}" "${R_STAGE_1}"

    # Remove most of the server components
    nspawn apt -y purge --autoremove bcache-tools btrfs-progs byobu cloud-init \
    cloud-initramfs-copymods cloud-initramfs-dyn-netconf curl eatmydata ethtool \
    finalrd git htop landscape-common lvm2 lxd-agent-loader mdadm \
    multipath-tools open-iscsi openssh-server openssh-sftp-server overlayroot \
    screen sosreport tmux vim xfsprogs

    if [ "${REL_VER}" == "20.04" ]; then
        nspawn apt-add-repository --yes ppa:ubuntu-pi-flavour-makers/ppa
    fi
    nspawn apt -y update
    nspawn apt -y dist-upgrade
    nspawn apt -y install cloud-guest-utils cloud-initramfs-growroot \
    libraspberrypi0 libraspberrypi-bin pi-bluetooth raspi-config rpi-eeprom
    # linux-modules-extra-raspi was introduce in 21.10 (Impish)
    case ${REL_VER} in
        21.10) nspawn apt -y install linux-modules-extra-raspi;;
    esac
    nspawn apt -y install ubuntu-mate-desktop^
}

function stage_03_snap() {
    export B="${B_STAGE_3}"
    export R="${R_STAGE_3}"
    sync_from "${B_STAGE_2}" "${R_STAGE_2}"

    local SEED_CHANNEL="stable/ubuntu-${REL_VER}"

    # Remove existing seeded snaps.
    rm -v ${R}/etc/systemd/system/snap-*.mount
    rm -v ${R}/etc/systemd/system/snap.lxd.*
    rm -v ${R}/etc/systemd/system/multi-user.target.wants/snap-*.mount
    rm -rfv ${R}/snap/*
    rm -rfv ${R}/var/lib/snapd/seed/*
    rm -fv ${R}/var/lib/snapd/snaps/*.snap
    rm -fv ${R}/var/lib/snapd/state.json
    rm -fv ${R}/var/lib/snapd/system-key
    mkdir -p ${R}/var/lib/snapd/seed/{assertions,snaps}
    snap known --remote model series=16 model=generic-classic brand-id=generic > ${R}/var/lib/snapd/seed/assertions/model
    local ACCOUNT_KEY=$(grep "^sign-key-sha3-384" ${R}/var/lib/snapd/seed/assertions/model | cut -d':' -f2 | sed 's/ //g')
    snap known --remote account account-id=generic > ${R}/var/lib/snapd/seed/assertions/account
    snap known --remote account-key public-key-sha3-384="${ACCOUNT_KEY}" > ${R}/var/lib/snapd/seed/assertions/account-key

    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps core18
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps core20
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps snapd
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps --channel=${SEED_CHANNEL} ubuntu-mate-welcome
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps software-boutique
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps ubuntu-mate-pi
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps --channel=${SEED_CHANNEL} gtk-theme-yaru-mate
    nspawn snap download --target-directory=/var/lib/snapd/seed/snaps --channel=${SEED_CHANNEL} icon-theme-yaru-mate

    nspawn snap prepare-image \
        --arch="${IMG_ARCH}" \
        --classic \
        --snap=core18 \
        --snap=core20 \
        --snap=snapd \
        --snap=gtk-theme-yaru-mate=${SEED_CHANNEL} \
        --snap=icon-theme-yaru-mate=${SEED_CHANNEL} \
        --snap=ubuntu-mate-welcome=${SEED_CHANNEL} \
        --snap=software-boutique \
        --snap=ubuntu-mate-pi \
        /var/lib/snapd/seed/assertions/model /

    mv ${R}/var/lib/snapd/seed/snaps/*.assert ${R}/var/lib/snapd/seed/assertions/
    rm -f ${R}/var/lib/snapd/seed/assertions/*.account
    rm -f ${R}/var/lib/snapd/seed/assertions/*.account-key
    rm -f ${R}/var/lib/snapd/seed/assertions/*.snap-declaration
    rm -f ${R}/var/lib/snapd/seed/assertions/*.snap-revision
}

function stage_04_config() {
    export B="${B_STAGE_4}"
    export R="${R_STAGE_4}"
    sync_from "${B_STAGE_3}" "${R_STAGE_3}"

# Instruct netplan to hand all network management to NetworkManager
    cat <<EOM > "${R}/etc/netplan/01-network-manager-all.yaml"
# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager
EOM

if [ "${REL_VER}"  == "20.04" ]; then
    cat <<EOM > "${B}/README"
An overview of the files on the /boot/firmware partition (the 1st partition
on the SD card) used by the Ubuntu boot process (roughly in order) is as
follows:

* bootcode.bin   - this is the second stage bootloader loaded by all pis with
                   the exception of the pi4 (where this is replaced by flash
                   memory)
* config.txt     - the first configuration file read by the boot process
* syscfg.txt     - the file in which system modified configuration will be
                   placed, included by config.txt
* usercfg.txt    - the file in which user modified configuration should be
                   placed, included by config.txt
* start*.elf     - the third stage bootloader, which handles device-tree
                   modification and which loads...
* uboot*.bin     - various u-boot binaries for different pi platforms; these
                   are launched as the "kernel" by config.txt
* boot.scr       - the boot script executed by uboot*.bin which in turn
                   loads...
* vmlinuz        - the Linux kernel, executed by boot.scr
* initrd.img     - the initramfs, executed by boot.scr
EOM
    cat <<EOM >> "${B}/config.txt"

# Enable the FKMS ("Fake" KMS) graphics overlay, enable the camera firmware
# and allocate 128Mb to the GPU memory
dtoverlay=vc4-fkms-v3d
gpu_mem=128
start_x=1

# Comment out the following line if the edges of the desktop appear outside
# the edges of your display
disable_overscan=1

# If you have issues with audio, you may try uncommenting the following line
# which forces the HDMI output into HDMI mode instead of DVI (which doesn't
# support audio output)
#hdmi_drive=2

# If you have a CM4, uncomment the following line to enable the USB2 outputs
# on the IO board (assuming your CM4 is plugged into such a board)
#dtoverlay=dwc2,dr_mode=host
EOM
    sed -i 's/enable_uart=1/enable_uart=0/' "${B}/config.txt"
    sed -i 's/enable_uart=1/enable_uart=0/' "${B}/syscfg.txt"
else
    # No uboot since 20.10
    if [ "${IMG_ARCH}"  == "arm64" ]; then
        ARM64="arm_64bit=1"
    else
        ARM64=""
    fi

    cat <<EOM > "${B}/README"
An overview of the files on the /boot/firmware partition (the 1st partition
on the SD card) used by the Ubuntu boot process (roughly in order) is as
follows:

* bootcode.bin   - this is the second stage bootloader loaded by all pis with
                   the exception of the pi4 (where this is replaced by flash
                   memory)
* config.txt     - the configuration file read by the boot process
* start*.elf     - the third stage bootloader, which handles device-tree
                   modification and which loads...
* vmlinuz        - the Linux kernel
* cmdline.txt    - the Linux kernel command line
* initrd.img     - the initramfs
EOM

    cat <<EOM > "${B}/config.txt"
[pi4]
max_framebuffers=2

[all]
${ARM64}
kernel=vmlinuz
cmdline=cmdline.txt
initramfs initrd.img followkernel

# Enable the audio output, I2C and SPI interfaces on the GPIO header
dtparam=audio=on
dtparam=i2c_arm=on
dtparam=spi=on

# Enable the FKMS ("Fake" KMS) graphics overlay, enable the camera firmware
# and allocate 128Mb to the GPU memory
dtoverlay=vc4-fkms-v3d
gpu_mem=128
start_x=1

# Comment out the following line if the edges of the desktop appear outside
# the edges of your display
disable_overscan=1

# If you have issues with audio, you may try uncommenting the following line
# which forces the HDMI output into HDMI mode instead of DVI (which doesn't
# support audio output)
#hdmi_drive=2

# If you have a CM4, uncomment the following line to enable the USB2 outputs
# on the IO board (assuming your CM4 is plugged into such a board)
#dtoverlay=dwc2,dr_mode=host
EOM
fi

    echo "net.ifnames=0 dwc_otg.lpm_enable=0 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline rootwait fixrtc quiet splash" > "${B}/cmdline.txt"

    # Disable Wifi power saving to improve WiFi performance on the Pi
    cat <<EOM > "${R}/etc/NetworkManager/conf.d/ZZraspi-wifi-powersave-off.conf"
[connection]
wifi.powersave = 2
EOM

    local DATE=""
    DATE=$(date +%m%H%M%S)
    local PASSWD=""
    PASSWD=$(mkpasswd -m sha-512 oem "${DATE}")
    nspawn addgroup --gid 29999 oem
    nspawn adduser --gecos "OEM Configuration (temporary user)" --add_extra_groups --disabled-password --gid 29999 --uid 29999 oem
    nspawn usermod -a -G adm,sudo -p "${PASSWD}" oem
    nspawn apt-get -y install --no-install-recommends oem-config-gtk ubiquity-frontend-gtk ubiquity-ubuntu-artwork oem-config-slideshow-ubuntu-mate
    # Force the slideshow to use Ubuntu MATE artwork.
    sed -i 's/oem-config-slideshow-ubuntu/oem-config-slideshow-ubuntu-mate/' ${R}/usr/lib/ubiquity/plugins/ubi-usersetup.py
    sed -i 's/oem-config-slideshow-ubuntu/oem-config-slideshow-ubuntu-mate/' ${R}/usr/sbin/oem-config-remove-gtk
    sed -i 's/ubiquity-slideshow-ubuntu/ubiquity-slideshow-ubuntu-mate/' ${R}/usr/sbin/oem-config-remove-gtk

    # Create files/dirs Ubiquity requires
    mkdir -p "${R}/var/log/installer"
    touch "${R}/var/lib/oem-config/run"
    touch "${R}/var/log/installer/debug"
    touch "${R}/var/log/syslog"
    nspawn chown syslog:adm /var/log/syslog
    nspawn /usr/sbin/oem-config-prepare --quiet

    # Install seeded snaps during oem-setup
    nspawn ln -s /lib/systemd/system/snapd.seeded.service /etc/systemd/system/oem-config.target.wants/snapd.seeded.service

    cat <<EOM > "${R}/usr/share/glib-2.0/schemas/50_ubuntu-mate-raspi-tweaks.gschema.override"
[org.mate.interface]
enable-animations=false

[org.mate.Marco.general]
compositing-manager=false

[org.mate.session.required-components]
windowmanager='marco-no-composite'
EOM

    nspawn glib-compile-schemas /usr/share/glib-2.0/schemas/

    # Create Raspberry Pi specific groups.
    nspawn groupadd -f --system gpio
    nspawn groupadd -f --system i2c
    nspawn groupadd -f --system input
    nspawn groupadd -f --system spi

    cat <<'EOM' > "${R}/usr/local/sbin/adduser.local"
#!/bin/sh
# This script is executed as the final step when calling `adduser`
# USAGE:
#   adduser.local USER UID GID HOME

# Add user to the Raspberry Pi specific groups
usermod -a -G adm,gpio,i2c,input,spi,video $1
EOM
    chmod 755 "${R}/usr/local/sbin/adduser.local"

    cat <<'EOM' > "${R}/etc/fstab"
LABEL=writable      /               ext4    defaults,noatime,x-systemd.growfs   0   0
LABEL=system-boot   /boot/firmware  vfat    defaults                            0   1
EOM
}

function stage_05_clean() {
    export B="${B_STAGE_5}"
    export R="${R_STAGE_5}"
    sync_from "${B_STAGE_4}" "${R_STAGE_4}"

    nspawn apt-get -y update
    nspawn apt-get -y upgrade
    nspawn apt-get -y dist-upgrade
    nspawn apt-get -y autoremove
    nspawn apt-get -y autoclean
    nspawn apt-get -y clean

    # Remove old kernel
    local OLD_KERNEL=$(ls -1 ${R}/lib/modules/ | head -n1)
    local OLD_KERNEL_SHORT=$(echo ${OLD_KERNEL} | sed s'/-raspi//')
    local NEW_KERNEL=$(ls -1 ${R_STAGE_4}/boot/vmlinuz-* | tail -n1 | awk -F/ '{print $NF}' | cut -d'-' -f2-4)
    echo "Old: ${OLD_KERNEL} (${OLD_KERNEL_SHORT})"
    echo "New: ${NEW_KERNEL}"
    if [ "${OLD_KERNEL}" == "${NEW_KERNEL}" ]; then
        echo "No old kernel to remove."
    else
        nspawn apt -y remove linux-image-${OLD_KERNEL} linux-modules-${OLD_KERNEL} linux-raspi-headers-${OLD_KERNEL_SHORT} 
        # linux-modules-extra-raspi was introduce in 21.10 (Impish)
        case ${REL_VER} in
            21.10) nspawn apt -y remove linux-modules-extra-${OLD_KERNEL};;
        esac
    fi

    # Copy new devicetree, overlays and kernel to /boot/firmware
    cp ${R}/lib/firmware/${NEW_KERNEL}/device-tree/*.dtb ${B}/
    cp ${R}/lib/firmware/${NEW_KERNEL}/device-tree/broadcom/*.dtb ${B}/
    cp ${R}/lib/firmware/${NEW_KERNEL}/device-tree/overlays/* ${B}/overlays/
    cp -av ${R}/boot/vmlinuz-${NEW_KERNEL} ${B}/vmlinuz
    cp -av ${R}/boot/initrd.img-${NEW_KERNEL} ${B}/initrd.img

    rm -f $R/etc/ssh/ssh_host_*_key*
    rm -f $R/boot/{*.bak,*.old}
    rm -f $B/{*.bak,*.old}
    rm -f $R/etc/apt/*.save
    rm -f $R/etc/apt/sources.list.d/*.save
    rm -f $R/var/log/apt/*
    rm -f $R/var/log/alternatives.log
    rm -f $R/var/log/dpkg.log
    rm -f $R/var/log/fontconfig.log
    rm -rf $R/tmp/*
    rm -f $R/var/crash/*
    rm -f $R/var/cache/debconf/*-old
    rm -f $R/var/lib/dpkg/*-old
    [ -L $R/var/lib/dbus/machine-id ] || rm -f $R/var/lib/dbus/machine-id
    echo '' > $R/etc/machine-id
    rm -f "${B}/meta-data"
    rm -f "${B}/network-config"
    rm -f "${B}/user-data"
}

function stage_06_image() {
    export B="${B_STAGE_5}"
    export R="${R_STAGE_5}"

    # Build the image file
    local SIZE_IMG=$(du -csh "${R}" | tail -n1 | cut -d'.' -f1)
    ((SIZE_IMG+=2))
    local SIZE_BOOT="256MiB"

    # Remove old images.
    rm -fv "${IMG_DIR}/${IMG_OUT}"

    # Create an empty file file.
    dd if=/dev/zero of="${IMG_DIR}/${IMG_OUT}" bs=1MB count=1
    dd if=/dev/zero of="${IMG_DIR}/${IMG_OUT}" bs=1MB count=0 seek=$(( ${SIZE_IMG} * 1000 ))

    # Initialising: msdos
    parted -s ${IMG_DIR}/${IMG_OUT} mktable msdos
    echo "Creating /boot/firmware partition"
    parted -a optimal -s ${IMG_DIR}/${IMG_OUT} mkpart primary fat32 1 "${SIZE_BOOT}"
    echo "Creating / partition"
    parted -a optimal -s ${IMG_DIR}/${IMG_OUT} mkpart primary ext4 "${SIZE_BOOT}" 100%
    echo "Making partition 1 bootable"
    parted -s ${IMG_DIR}/${IMG_OUT} set 1 boot on

    PARTED_OUT=$(parted -s ${IMG_DIR}/${IMG_OUT} unit b print)
    BOOT_OFFSET=$(echo "${PARTED_OUT}" | grep -e '^ 1'| xargs echo -n \
    | cut -d" " -f 2 | tr -d B)
    BOOT_LENGTH=$(echo "${PARTED_OUT}" | grep -e '^ 1'| xargs echo -n \
    | cut -d" " -f 4 | tr -d B)

    ROOT_OFFSET=$(echo "${PARTED_OUT}" | grep -e '^ 2'| xargs echo -n \
    | cut -d" " -f 2 | tr -d B)
    ROOT_LENGTH=$(echo "${PARTED_OUT}" | grep -e '^ 2'| xargs echo -n \
    | cut -d" " -f 4 | tr -d B)

    BOOT_LOOP=$(losetup --show -f -o ${BOOT_OFFSET} --sizelimit ${BOOT_LENGTH} ${IMG_DIR}/${IMG_OUT})
    ROOT_LOOP=$(losetup --show -f -o ${ROOT_OFFSET} --sizelimit ${ROOT_LENGTH} ${IMG_DIR}/${IMG_OUT})
    echo "/boot/firmware: offset ${BOOT_OFFSET}, length ${BOOT_LENGTH}"
    echo "/:              offset ${ROOT_OFFSET}, length ${ROOT_LENGTH}"

    mkfs.vfat -n system-boot -S 512 -s 16 -v "${BOOT_LOOP}"
    mkfs.ext4 -L writable -m 0 "${ROOT_LOOP}"

    mount -v "${ROOT_LOOP}" "${LOOP_DIR}" -t ext4
    mkdir -p "${LOOP_DIR}/boot/firmware"
    mount -v "${BOOT_LOOP}" "${LOOP_DIR}/boot/firmware" -t vfat
    echo "Syncing root..."
    rsync -aHAXx --delete ${R}/ "${LOOP_DIR}/"
    echo "Syncing boot..."
    rsync -aHAXx --delete ${B}/ "${LOOP_DIR}/boot/firmware/"
    date +"%Y%m%d" > "${LOOP_DIR}/.disk/info"
    sync
    umount -l "${LOOP_DIR}/boot/firmware"
    umount -l "${LOOP_DIR}"
    losetup -d "${ROOT_LOOP}"
    losetup -d "${BOOT_LOOP}"
    ls -lh "${IMG_DIR}/${IMG_OUT}"
    echo "Compressing ${IMG_OUT}.xz"
    rm "${IMG_DIR}/${IMG_OUT}.xz" 2>/dev/null
    xz --keep -T 0 "${IMG_DIR}/${IMG_OUT}"
    ls -lh "${IMG_DIR}/${IMG_OUT}.xz"
}

function stage_07_hash() {
    export B="${B_STAGE_5}"
    export R="${R_STAGE_5}"

    local HASH="sha256"
    local KEY="FFEE1E5C"

    local OUT_HASH="${IMG_DIR}/${IMG_OUT}.xz.${HASH}"
    local OUT_SIGN="${IMG_DIR}/${IMG_OUT}.xz.${HASH}.sign"

    rm -f "${OUT_HASH}"
    rm -f "${OUT_SIGN}"

    if [ -e "${IMG_DIR}/${IMG_OUT}.xz" ]; then
        echo "Hashing ${IMG_OUT}.xz"
        ${HASH}sum "${IMG_DIR}/${IMG_OUT}.xz" > "${OUT_HASH}"
        sed -i -r "s/ .*\/(.+)/  \1/g" "${OUT_HASH}"
        gpg --default-key ${KEY} --armor --output ${OUT_SIGN} --detach-sig ${OUT_HASH}
    else
        echo "WARNING! Didn't find ${IMG_DIR}/${IMG_OUT} to hash."
    fi
}

if [ $(id -u) -ne 0 ]; then
    echo "ERROR! Root permissions required."
    exit 1
fi

# Take command line arguments
if [ $# -lt 1 ]; then
    usage
    exit 0
else
    while [ $# -gt 0 ]; do
        case "${1}" in
            -img|--img)
                IMG="${2}"
                if [ ! -e "${IMG}" ]; then
                    echo "[!] ERROR: ${IMG} was not found."
                    exit 1
                fi
                shift
                shift;;
            *)
                echo "[!] ERROR: \"${1}\" is not a supported parameter."
                usage
                exit 1;;
        esac
    done
fi

FLAVOUR="ubuntu-mate"
TMP_DIR="/var/cache/ubuntu-pi-image"
IMG_DIR=$(pwd)
IMG_QUALITY="-beta3"
IMG_QUALITY=""
IMG_VER=$(echo "${IMG}" | cut -d'-' -f2)
REL_VER=$(echo ${IMG_VER} | cut -d'.' -f1-2)
IMG_ARCH=$(echo "${IMG}" | cut -d'+' -f1 | cut -d'-' -f5)
IMG_OUT=$(echo "${IMG}" | sed "s/ubuntu-/${FLAVOUR}-/" | sed 's/preinstalled-server-/desktop-/' | sed "s/${IMG_VER}/${IMG_VER}${IMG_QUALITY}/")
IMG_TEST=$(file -b "${IMG}" | cut -d';' -f1)

# Create stage caches
for LOOP in 0 1 2 3 4 5; do
    export B_STAGE_${LOOP}="${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${REL_VER}/boot_${LOOP}"
    export R_STAGE_${LOOP}="${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${REL_VER}/root_${LOOP}"
    mkdir -p "${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${REL_VER}/boot_${LOOP}" 2>/dev/null
    mkdir -p "${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${REL_VER}/root_${LOOP}" 2>/dev/null
done

# Create the mount point for loopback devices
LOOP_DIR="${TMP_DIR}/${IMG_ARCH}/${FLAVOUR}/${REL_VER}/loop"
mkdir -p "${LOOP_DIR}" 2>/dev/null

if [ "${IMG_TEST}" == "DOS/MBR boot sector" ]; then
    stage_00_tools
    stage_01_unpack
    stage_02_apt
    stage_03_snap
    stage_04_config
    stage_05_clean
    stage_06_image
    stage_07_hash
else
    echo "[!] ERROR: ${IMG} is not a valid disk image."
    if [ "${IMG_TEST}" == "XZ compressed data" ]; then
        echo "           Try decompressing ${IMG} first using:"
        echo "           unxz --decompress --keep ${IMG}"
    fi
    exit 1
fi
